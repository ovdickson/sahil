name: Docker image build and publish
on:
  push:
    branches: [ migrate-to-aws ]

  workflow_dispatch:
    inputs:
      path_to_dockerfile:
        description: Path to the dockerfile (default = 'Dockerfile')
        default: "infra/docker/Dockerfile.website"
        type: string
      docker_build_dir:
        description: Docker build directory (default = '.')
        default: "infra/docker"
        type: string
      image_tag:
        description: Tag to apply to images.
        type: string
        default: snapshot-artifact
      lifecycle_policy_file:
        description: Path to the lifecycle policy JSON file (default = 'policy.json')
        required: true
        default: "infra/policy.json"
        type: string
      backend_s3_bucket:
        description: Name of the S3bucket for Terraform backend
        required: true
        default: "sahil-terraform-table-bucket"
        type: string
      backend_iam_role:
        description: Name of the Terraform backend assumable IAM Role
        default: "workload-assumable-role"
        type: string
      github_iam_role:
        description: Name of the IAM Role for adding access to ECR repo
        default: "sahil-deployment-role "
        type: string
      aws_account_id:
        description: AWS Account ID
        required: true
        default: "060795911441"
        type: string
      aws_region:
        description: Target AWS Region
        default: "eu-west-1"
        type: string
      backend_dynamodb_table:
        description: DynamoDB table for State lock
        required: true
        default: "sahil-terraform-table-locks"
        type: string

# concurrency required to avoid terraform lock contention during ECR provisioning
concurrency: ci-${{ github.repository }}-docker-pipeline

jobs:
  docker:
    runs-on: ubuntu-latest
    env:
      LIFECYCLE_POLICY: |
       
        {
          "rules": [
            {
              "rulePriority": 1,
              "description": "Keep last 1 image",
              "selection": {
                "tagStatus": "tagged",
                "tagPrefixList": [ "snapshot" ],
                "countType": "imageCountMoreThan",
                "countNumber": 1
              },
              "action": {
                "type": "expire"
              }
            }
          ]
        }

    permissions:
      id-token: write
      contents: read

    outputs:
      image_tag: ${{ steps.build-publish.outputs.image_tag }}
      full_image: ${{ steps.build-publish.outputs.full_image }}

    steps:
      - uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.ACCOUNT_ID }}:role/${{ vars.ROLE_NAME }}
          role-session-name: github_action_session
          aws-region: ${{ vars.REGION }}

      - name: Get OIDC Token
        id: get_oidc_token
        run: |
          curl -s -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" "$ACTIONS_ID_TOKEN_REQUEST_URL&audience=sts.amazonaws.com" | jq -r '.value' > /tmp/web_identity_token_file


      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: prepare ECR repo name based on the Github repository
        shell: bash
        run: |
          set -eux
          # lowercase the name
          repo="${GITHUB_REPOSITORY,,}"

          # replace / with _
          echo "ECR_REPO_NAME=${repo//\//_}" >> $GITHUB_ENV

          

      - name: TF init
        shell: bash
        run: |
          set -eux
          terraform init -upgrade -reconfigure \
            -input=false \
            -backend-config="key=docker-ecr/terraform-${{ env.ECR_REPO_NAME }}.tfstate" \
            -backend-config="role_arn=arn:aws:iam::${{vars.ACCOUNT_ID}}:role/${{vars.BACKEND_IAM_ROLE}}"
            # terraform force-unlock -force 1f0bd248-d99d-a23f-6669-47e57dcedd87
        working-directory: infra/terraform

      - name: Terraform Plan
        shell: bash 
        run: |
          set -eux
          terraform plan \
          -var 'repository_name=${{ env.ECR_REPO_NAME }}' \
          -var 'lifecycle_policy=${{ env.LIFECYCLE_POLICY }}' \
          -var 'iam_role=arn:aws:iam::${vars.ACCOUNT_ID}:role/${vars.ROLE_NAME}' \
          -var 'aws_account_id=${{ vars.ACCOUNT_ID }}' \
          -out terraform.plan
        working-directory: infra/terraform

      - name: Check for Terraform Plan errors
        shell: bash
        run: |
          set -eux
          if [[ -s terraform.plan ]]; then
            cat terraform.plan
            exit 1
          fi
  
      - name: Terraform Plan Status
        if: steps.plan.outcome == 'failure'
        run: exit 1  

      - name: Create ECR repo [TF apply]
        shell: bash
        run: |
          set -eux
          terraform apply \
            -var 'repository_name=${{ env.ECR_REPO_NAME }}' \
            -var 'lifecycle_policy=${{ env.LIFECYCLE_POLICY }}' \
            -var 'iam_role=arn:aws:iam::${vars.ACCOUNT_ID}:role/${vars.ROLE_NAME}' \
            -var 'aws_account_id=${{ vars.ACCOUNT_ID }}' \
            -auto-approve
        working-directory: infra/terraform

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registries: ${{ vars.ACCOUNT_ID }}

      - name: Build, tag, and push images to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REPO_NAME }}
          DOCKER_BUILD_DIR: "."  # Use the root directory as the build context
        run: |
          # Read the list of Dockerfiles
          DOCKERFILES="${{ steps.find-dockerfiles.outputs.dockerfiles }}"
          
          # Iterate over each Dockerfile
          while IFS= read -r dockerfile; do
            # Extract the service name from the Dockerfile name (e.g., Dockerfile.website -> website)
            service_name=$(basename "$dockerfile" | sed 's/^Dockerfile\.//')
            
            # Check if service_name is empty and use a default if it is
            if [ -z "$service_name" ]; then
              service_name="default"
            fi
            
            # Set a unique IMAGE_TAG for this service
            IMAGE_TAG="${service_name}-artifact-v1"
            
            echo "Dockerfile: $dockerfile"
            echo "Service name: $service_name"
            echo "Image tag: $IMAGE_TAG"

            echo "Building and pushing $service_name"
            
            # Build the Docker image
            docker build -f "$dockerfile" -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $DOCKER_BUILD_DIR
            
            # Push the image to ECR
            docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
            
            echo "Image $IMAGE_TAG pushed to $ECR_REGISTRY/$ECR_REPOSITORY"
            
            # Output the image tag for use in subsequent steps if needed
            echo "${service_name}_image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          done <<< "$DOCKERFILES"


      